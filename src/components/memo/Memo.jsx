import React, { memo, useState } from "react";

import c from './memo.module.css';

//Функция memo используется для оптимизации отрисовки дочернего компонента компонента

//при каждом изменении props
//Реакт создает новое shadow-dom дерево для сравнения и отрисовки
//при достаточео больших приложениях постоянные перерисовки могут тормозить браузер
//так как dom большой и ооочень медленный по сравнению с JS

//в таких случаях мы можем оптимизировать рендер с помощю memo

//оптимизированая компонента возвращает новую компоненту
//и если конкретно ее пропсы не изменились перерисовка не происходить

//таким образом мы можем оптимизировать рендер частей нашего приложения

function Title (props){
    console.log(`Компонент отрендерился с ${props.text} значением.`);

    return (
        <h2>
            {props.text}
        </h2>
    );
};

const OptimazedTitle = memo(Title);

const Wrapper = () => {
    const [isReversed, reverse] = useState(false);

    const text = 'Нажимай меня)';

    const onClickHandler = () => {
        reverse(isReversed => !isReversed);
    };

    return (
        <div 
            onClick={onClickHandler}>
            <h2>
                {
                    isReversed
                        ? text.split('').reverse().join('')
                        : text
                }
            </h2>

            <OptimazedTitle text="First Optimazed"/>

            <OptimazedTitle text="Second Optimazed"/>

            <Title text="Not Optimazed"/>
        </div>
    );
};

export default Wrapper;

//Если запустить пример то мы увидим что в первом рендере
//отрендерятся все дочерние компоненты
//а при клике и перерендере родительского компонента
//будет рендерится только не оптимизированый

//чтобы понять в каком компоненте изменились пропсы
//мемо сравнивает значения предидущих пропсов с текущими поверхностно

//то есть, если мы сравниваем элементарные значения то все будет ок
//но если сравниваются обьекты в свойствах которых есть еще объекты
//то сравнение ни к чему не приведет

//для таких случаев в реакт дает возможность вторым аргументом
//в memo передать функцию которая отработает
//а если вернет true перерендер несостоится
//а если false то вызовется компонент
function MyComponent(props) {}

function areEqual(prevProps, props) {
  /*
    функция принимает первым аргументом предидущие пропсы
    вторым текущие
    Если вы возвращаете true, это значит, что ничего не изменилось и вызывать компонент не нужно
  */
}

React.memo(MyComponent, areEqual);

//функция memo ничего не даст если компонент вызвал сам себя
//с помощю useContext or useState
